"""
Assets Mapper - Create asset name-to-GUID mappings from XML files.

Generates mappings from asset XML files and outputs to Python or JSON format.
Supports optional regex filtering and flexible output locations.
"""

# ============================================================
# IMPORTS
# ============================================================

import json
import re
import xml.etree.ElementTree as ET
from pathlib import Path
from typing import Optional

from ..cache import get_cached_asset, set_cached_asset
from ..config import get_file_path
from ..log import log
from ..utils import (
    sanitize_filename,
    generate_constant_name,
    load_xml_file,
    CustomArgumentParser,
)

# ============================================================
# PARSING
# ============================================================


def _parse_asset_file(
    xml_path: Path, name_filter: Optional[str] = None
) -> dict[str, int]:
    """
    Parse XML asset file and create Name -> GUID mapping.

    Args:
        xml_path: Path to the asset XML file to parse.
        name_filter: Optional regex pattern to filter asset names.

    Returns:
        Dictionary mapping asset names (str) to GUIDs (int).

    Raises:
        FileNotFoundError: If XML file not found.
        ET.ParseError: If XML is malformed.
    """
    if not xml_path.exists():
        raise FileNotFoundError(f"XML file not found: {xml_path}")

    root = load_xml_file(xml_path)
    if root is None:
        raise RuntimeError(f"Failed to parse XML: {xml_path}")

    mapping = {}
    regex = re.compile(name_filter) if name_filter else None

    for asset in root.findall("Asset"):
        name_node = asset.find("Values/Standard/Name")
        guid_node = asset.find("Values/Standard/GUID")

        if name_node is None or guid_node is None:
            continue

        name = name_node.text.strip() if name_node.text else ""
        guid_str = guid_node.text.strip() if guid_node.text else ""

        if not name or not guid_str:
            continue

        try:
            guid = int(guid_str)
        except ValueError:
            log(f"{{err/Invalid GUID value: {guid_str} for asset: {name}}}")
            continue

        # Apply regex filter if provided
        if regex and not regex.search(name):
            continue

        mapping[name] = guid

        # Cache the asset for future lookups
        template_node = asset.find("Template")
        template = template_node.text if template_node is not None else "Unknown"
        set_cached_asset(
            guid_str,
            {
                "guid": guid_str,
                "name": name,
                "template": template,
                "file": xml_path.name,
            },
        )

    return mapping


# ============================================================
# OUTPUT
# ============================================================


def _write_python_mapping(
    output_path: Path,
    mapping: dict[str, int],
    xml_path: Path,
    constant_name: str,
    command_line: str = "",
) -> None:
    """
    Write asset mapping to Python file.

    Args:
        output_path: Path to output .py file.
        mapping: Asset name->GUID dictionary.
        xml_path: Source XML file path (for documentation).
        constant_name: Name of the constant to use in the file.
        command_line: Command line used to generate this file.
    """
    output_path.parent.mkdir(parents=True, exist_ok=True)

    with output_path.open("w", encoding="utf-8") as f:
        f.write("# Auto-generated asset pool map\n")
        f.write(f"# Source XML: {xml_path}\n")
        if command_line:
            f.write(f"# Generated by: {command_line}\n")
        f.write(f"\n{constant_name} = {{\n")

        for name, guid in sorted(mapping.items()):
            safe_name = name.replace('"', '\\"')
            f.write(f'    "{safe_name}": {guid},\n')

        f.write("}\n")

    log(f"Python mapping written: {output_path}")


def _write_json_mapping(
    output_path: Path,
    mapping: dict[str, int],
    xml_path: Path,
    command_line: str = "",
) -> None:
    """
    Write asset mapping to JSON file.

    Args:
        output_path: Path to output .json file.
        mapping: Asset name->GUID dictionary.
        xml_path: Source XML file path (for documentation).
        command_line: Command line used to generate this file.
    """
    output_path.parent.mkdir(parents=True, exist_ok=True)

    data = {
        "source": str(xml_path),
        "mapping": mapping,
    }
    if command_line:
        data["command_line"] = command_line

    with output_path.open("w", encoding="utf-8") as f:
        json.dump(data, f, indent=2, ensure_ascii=False)

    log(f"JSON mapping written: {output_path}")


# ============================================================
# CLI
# ============================================================


def build_parser(parser: CustomArgumentParser) -> None:
    """Build argument parser for assets_mapper."""
    assets_dir = get_file_path("assets_unpack_dir")
    gen_dir = get_file_path("gen_dir")

    parser.add_argument(
        "-t",
        "--template",
        type=str,
        required=True,
        help="Asset XML filename (e.g., AssetPoolNamed.xml)",
    )
    parser.add_argument(
        "-ad",
        "--assets-dir",
        type=Path,
        default=assets_dir,
        help=f"Assets directory (default: {assets_dir})",
    )
    parser.add_argument(
        "-of",
        "--output-format",
        type=str,
        choices=["python", "json"],
        default="python",
        help="Output format (python or json)",
    )
    parser.add_argument(
        "-od",
        "--output-dir",
        type=Path,
        default=gen_dir,
        help=f"Output directory for generated mappings (default: {gen_dir})",
    )
    parser.add_argument(
        "--filter",
        type=str,
        default=None,
        help="Optional regex pattern to filter asset names",
    )


def run(parsed: CustomArgumentParser) -> int:
    """
    Main entry point for assets_mapper module.

    Args:
        parsed: Parsed command-line arguments.

    Returns:
        Exit code (0 on success, non-zero on failure).
    """

    try:
        # Locate asset file in assets directory
        asset_path = parsed.assets_dir / parsed.template

        if not asset_path.exists():
            log(f"Asset file not found: {asset_path}", "error")
            return 1

        log(f"Parsing asset file: {asset_path}")

        # Create mapping
        mapping = _parse_asset_file(asset_path, parsed.filter)
        log(f"Extracted {len(mapping)} asset mappings")

        if not mapping:
            log("No assets found matching criteria", "error")
            return 1

        # Prepare output
        output_dir = parsed.output_dir
        output_dir.mkdir(parents=True, exist_ok=True)
        asset_stem = asset_path.stem

        # Generate output filename and constant name
        safe_filename = sanitize_filename(asset_stem)
        constant_name = generate_constant_name(parsed.template)

        # Build command line for documentation
        cmd_parts = ["python main.py --cli assets_mapper", f"-t {parsed.template}"]
        if parsed.filter:
            cmd_parts.append(f"--filter {parsed.filter}")
        command_line = " ".join(cmd_parts)

        if parsed.output_format == "python":
            output_file = output_dir / f"{safe_filename}.py"
            _write_python_mapping(
                output_file, mapping, asset_path, constant_name, command_line
            )
        else:  # json
            output_file = output_dir / f"{safe_filename}.json"
            _write_json_mapping(output_file, mapping, asset_path, command_line)

        log("Asset mapping complete âœ“", "success")
        return 0

    except FileNotFoundError as e:
        log(f"File error: {e}", "error")
        return 1
    except ET.ParseError as e:
        log(f"XML parse error: {e}", "error")
        return 1
    except Exception as e:
        log(f"Unexpected error: {e}", "error")
        return 1
