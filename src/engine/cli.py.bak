"""
Command-line argument parsing for Atayeb Assets Explorer.

Provides a custom ArgumentParser that raises exceptions instead of exiting.
"""

# ============================================================
# IMPORTS
# ============================================================

import argparse
import re
import src.engine.config as Config
import src.engine.logger as Logger
from pathlib import Path
from types import ModuleType
from tkinter import Tk, filedialog


def _select_file_gui(title: str = "Select a file") -> str:
    """Open file picker with tkinter (improved for interactive mode)."""
    root = Tk()
    root.withdraw()
    root.attributes("-topmost", True)  # Force au premier plan
    root.update()  # Force le rendu

    filepath = filedialog.askopenfilename(title=title)

    root.destroy()
    root.update()  # Nettoie aprÃ¨s fermeture
    return filepath


def select_file(
    key: str = "Select a file",
    default: str = "",
    autoconfirm: bool = False,
    stream: bool = False,
    silent: bool = False,
):
    """Ask user to input file path."""
    from src.config import ConfigPath, get_bool_value

    if autoconfirm and default is not None:
        return ConfigPath(
            prompt(key, default=default, autoconfirm=True, stream=stream, silent=silent)
        )

    if get_bool_value("cli.gui_file_chooser"):
        Logger.get().prompt(f"Using GUI file chooser for: {key}")
        file = _select_file_gui(key)
        if file == "":
            file = default
        return ConfigPath(file)
    return ConfigPath(
        prompt(key, default=default, autoconfirm=False, stream=stream, silent=silent)
    )


def prompt(
    key: str = None,
    default: str = "",
    autoconfirm: bool = False,
    silent=False,
    ex: bool = False,
    ex_type: str = "none",
) -> str:
    """Ask user to input text."""
    logger = Logger.get()
    out_confirm = lambda instant=False: logger.prompt(
        f"Please confirm /;cy/[{key}]/; (/;_arrow/cg;bo;/ /;cw;di/{default}/;): ",
        end="",
        instant=instant,
    )
    out_provide_ex = lambda instant=False: logger.prompt(
        f"Please provide {ex_type} /;cy/[{key}]/; (/;_arrow/cg;bo;/ /;cw;di/{default}/;): ",
        end="",
        instant=instant,
    )
    out_autoconfirm = lambda instant=False: logger.prompt(
        f"Provided [{key}]: ",
        end="",
        instant=instant,
    )

    input_value = ""
    if autoconfirm:
        if not silent:
            out_autoconfirm()
        input_value = default
    else:
        if ex:
            # out_debug_ex()
            out_provide_ex()
        else:
            out_confirm()
        input_value = input().strip()
        logger.clean_lines(1)
        if ex:
            out_provide_ex(True)
        else:
            out_confirm(True)

    if input_value == "":
        input_value = default

    if input_value is None or input_value is False:
        logger.error(f"{input_value}")
    elif input_value == "":
        logger.print(f"/;cw;di/(empty)/;")
    else:
        logger.success(f"{input_value}")
    return input_value


def prompt_for_arg(
    key: str = None,
    default=None,
    is_file: bool = False,
    autoconfirm: bool = False,
    silent: bool = False,
    ex: bool = False,
    ex_type: str = "none",
) -> str:
    if is_file:
        return select_file(
            key,
            default=default,
            autoconfirm=autoconfirm,
            silent=silent,
            ex=ex,
            ex_type=ex_type,
        )
    else:
        return prompt(
            key,
            default=default,
            autoconfirm=autoconfirm,
            silent=silent,
            ex=ex,
            ex_type=ex_type,
        )


# ============================================================
# ARGUMENT PARSING
# ============================================================

CLI_ARGUMENTS = [
    "help",
    "instant",
    "silent",
    "live",
    "confirm",
    "print_args",
]


class CliArgumentParser(argparse.ArgumentParser):
    """ArgumentParser that raises exceptions instead of exiting."""

    def __init__(
        self, module: ModuleType, module_args: list[str] | None = None, *args, **kwargs
    ):
        self.simple_module_name = module.__name__.split(".")[-1]
        self.module_name = module.__name__
        self.module = module
        self.cli_params = dict()
        self.module_params = dict()
        self._init_args = module_args or []
        self.hint = False

        super().__init__(add_help=False, exit_on_error=False, *args, **kwargs)
        for arg in CLI_ARGUMENTS:
            default = None  # get_value_or_none(f"cli.{arg}", default=False)
            self.add_argument(arg, default=default, action="store_true", cli=True)

        build_parser_func = getattr(self.module, "build_parser")
        build_parser_func(self)
        self._consume_module_args()

    def add_argument(self, long: str, cli: bool = False, **kwargs):
        """Add argument with short and long form, passing through all argparse options."""

        short_form = f"-{long[0]}"
        # Check if short form is already used
        if any(
            p["short"] == short_form
            for p in [*self.cli_params.values(), *self.module_params.values()]
        ):
            short_form = None  # Skip short form if conflict

        long_form = f"--{long.replace('_', '-')}"
        store = self.cli_params if cli else self.module_params
        store[long] = {
            "short": short_form,
            "long": long_form,
            "kwargs": kwargs,
        }

        # Add argument to argparse
        if short_form:
            super().add_argument(short_form, long_form, **kwargs)
        else:
            super().add_argument(long_form, **kwargs)

    def module_arg(self, key: str):

        confirm_run = self.cli("confirm")
        silent_run = self.cli("silent")
        instant_run = self.cli("instant")
        live_run = self.cli("live")

        kwargs = self.module_params.get(key, {}).get("kwargs", {})
        type = kwargs["type"] if "type" in list(kwargs.keys()) else None

        argument_value = getattr(
            self.module_parsed, key.replace("--", "").replace("-", "_"), None
        )
        is_file = False  # type is not None and isinstance(
        #     type(argument_value if argument_value is not None else ""), ConfigPath
        # )
        if is_file:
            config_value = None  # get_file_path(key)
        else:
            config_value = None  # get_value_or_none(key)
        if not live_run:
            argument_value = argument_value if argument_value else config_value
        else:
            if not self.hint:
                # log("{arr/}Leave inputs {hvl/(empty)} for {hul/default}")
                self.hint = True
            argument_value = prompt_for_arg(
                key,
                default=argument_value,
                is_file=is_file,
                autoconfirm=not confirm_run,
                silent=silent_run,
            )

        if argument_value is not None and type is not None:
            return type(argument_value)
        return (Path.cwd() / argument_value) if is_file else argument_value

    def cli(self, flag: str) -> bool:
        """Get CLI parsed arguments."""
        return getattr(
            self.cli_parsed,
            flag,
            None,  # get_value_or_none(f"cli.{flag}", default=False)
        )

    def handle_parse_error(self, kill: int, error: argparse.ArgumentError) -> None:
        def extract_form(pattern, text):
            match = re.search(pattern, text)
            return match.group(0) if match else None

        message = str(error)
        ex_type = "missing"
        if "required" in message:
            ex_type = "required"
        elif "expected" in message:
            ex_type = "expected"
        elif "unrecognized" in message:
            ex_type = "unrecognized"
        short_form = extract_form(r"-[a-zA-Z]+", message)
        long_form = extract_form(r"--[a-zA-Z-]+", message)
        self._init_args = [
            arg for arg in self._init_args if arg not in [short_form, long_form]
        ]
        if ex_type == "unrecognized":
            Logger.get().debug(
                f" Skipping unrecognized argument: {long_form if long_form else short_form} "
            )
            return
        argument_prompt = prompt_for_arg(long_form, ex=True, ex_type=ex_type)
        if argument_prompt:
            self._init_args = [*self._init_args, long_form, argument_prompt]
        elif ex_type == "required":
            Logger.get().clean_lines()

    def check_if_module_arg(self, arg: str) -> bool:
        """Check if a module parameter exists."""
        long_check = arg.startswith("--")
        if long_check:
            return arg[2:].replace("-", "_") in list(self.module_params.keys())
        else:
            return any(arg[1:] == p["short"] for p in list(self.module_params.values()))

    # def check_if_module_arg(self, arg: str) -> bool:
    #     """Check if a module parameter exists."""
    #     long_check = arg.startswith("--")
    #     if long_check:
    #         log("checking: " + arg[2:].replace("-", "_"))
    #         return arg[2:].replace("-", "_") in list(self.module_params.keys())
    #     else:
    #         log("checking: " + arg[1:])
    #         return any(arg[1:] == p["short"] for p in list(self.module_params.values()))

    def _consume_module_args(self) -> None:
        """Parse arguments."""
        exception = True
        max_same = 4
        kill = max_same
        while exception:
            try:
                last = exception
                parsed = super().parse_args(self._init_args)
                exception = False
            except argparse.ArgumentError as e:
                exception = e
            if exception:
                same = f"{last}" == f"{exception}"
                if same and kill == 1:
                    raise exception
                elif not same:
                    kill = max_same
                else:
                    kill -= 1
                if kill < max_same:
                    Logger.get().debug(
                        f" {kill} tries left " if kill > 1 else " last try ",
                        end="",
                        instant=True,
                    )
                self.handle_parse_error(kill, exception)

        filtered = {
            k: v for k, v in vars(parsed).items() if k in self.cli_params.keys()
        }
        self.cli_parsed = argparse.Namespace(**filtered)
        filtered = {
            k: v for k, v in vars(parsed).items() if k in self.module_params.keys()
        }
        self.module_parsed = argparse.Namespace(**filtered)
